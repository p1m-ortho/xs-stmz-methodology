# METHOD.md

## Частота осложнений операций на позвоночнике…: журнал исследования (ПВЖ)

Запрос к базе выполнил, результаты сохранил 2019-03-07 23:26.

| Категория           | Число записей |
|---------------------|---------------|
| Всего               | 3940          |
| Спинальная КТ       | 3294          |
| Спинальная операция | 646           |

При попытке удалить 100%-ные дубликаты в офисных программах (Excel 2016 for Mac, Calc 4.1.5) столкнулся с вылетами и зависаниями.

Поэтому решил загрузить все записи в БД (MySQL), и уже там продолжить с ними работу.

Структура БД:

```sql
CREATE TABLE `20190307_2326_xc` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `mrn` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `upi` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `last` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `first` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `middle` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sex` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `dob` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `doa` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `dod` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `note_specialty` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `note_type` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `note_text` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `phone_home` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `phone_mobile` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `phone_comment` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `registration_address` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `home_address` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `icd10_code` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `ward_field` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_code` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_date` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_asa` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_acuteness` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_name` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_type` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_timing` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_an_type` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_an_start` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_an_end` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `sx_postop_dx` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `free_text` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `spinality_type` text COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

| Название поля в запросе                 | Название поля в FormTools |
|-----------------------------------------|---------------------------|
| № ИБ                                    | mrn                       |
| Комп. номер пациента                    | upi                       |
| Фамилия                                 | last                      |
| Имя                                     | first                     |
| Отчество                                | middle                    |
| Пол                                     | sex                       |
| Дата рождения                           | dob                       |
| Дата поступления                        | doa                       |
| Дата выписки                            | dod                       |
| Вид осмотра                             | note_specialty            |
| Тип осмотра                             | note_type                 |
| Протокол осмотра                        | note_text                 |
| Телефон дом.                            | phone_home                |
| Телефон сот.                            | phone_mobile              |
| Комментарий                             | phone_comment             |
| Адрес регистрации                       | registration_address      |
| Адрес проживания                        | home_address              |
| Диагноз по МКБ-10                       | icd10_code                |
| поле-индикатор пребывания на отделениях | ward_field                |
| Код операции                            | sx_code                   |
| Дата операции                           | sx_date                   |
| ASA                                     | sx_asa                    |
| Экстренная/ плановая                    | sx_acuteness              |
| Полное наименование операции            | sx_name                   |
| Тип операции                            | sx_type                   |
| Часов от момента поступления            | sx_timing                 |
| Вид обезболивания                       | sx_an_type                |
| Начало наркоза                          | sx_an_start               |
| Окончание наркоза                       | sx_an_end                 |
| Послеоперационный диагноз               | sx_postop_dx              |
| Описание операции/КТ/МРТ                | free_text                 |
| Вид спинальности                        | spinality_type            |

Пришлось для этого добавить поле ID в оригинальную таблицу, убрать шапку (оригинальный запрос возвращает еще свое название и параметры в первых строчках таблицы) и строку заголовков.

Итак, загрузилось успешно, 3940 записей, кодировки на месте, все поля совпадают, текст не обрезался.

Выбираю без дубликатов:

```sql
SELECT DISTINCT *
FROM `20190307_2326_xc`
```

Итого все те же 3940 записей.

| Категория                                | Число записей |
|------------------------------------------|---------------|
| Всего                                    | 3940          |
| Всего после удаления 100%-ных дубликатов | 3940          |
| Спинальная КТ                            | 3294          |
| Спинальная операция                      | 646           |

Приступаю к случайной сортировке записей.

Для этого в оригинальном CSV добавляю новое поле под случайные числа.

Генерирую на RANDOM.ORG 3294 чисел (`RANDOM.ORG - Integer Set Generator.html` прилагаю).

Заменяю запятую с пробелом на перенос строки.

Сортирую записи по возрастанию по типу спинальности, вставляю 3294 в поле под случайные числа для «Спинальных КТ/МРТ» — успешно.

Генерирую на RANDOM.ORG 646 чисел (`RANDOM.ORG - Integer Set Generator.html` прилагаю).

Заменяю запятую с пробелом на перенос строки.

Вставляю 646 в поле под случайные числа для «Спинальных операций» — успешно.

Нет, так не пойдет, потому что необходимо записи отсортировать так, чтобы группы: ФИО + дата рождения — были отсортированы вначале по типу спинальности, а затем по полю со случайным числом.

А так получится, только если отсортировать случайно авторов, а не записи.

Поэтому делаю запрос:

```sql
SELECT `last`, `first`, `middle`, `dob`, `upi`
FROM `20190307_2326_xc`
GROUP BY `last`, `first`, `middle`, `dob`
```

| Категория                                       | Число |
|-------------------------------------------------|-------|
| Всего записей                                   | 3940  |
| Всего записей с различными ФИО и датой рождения | 1942  |

Кстати говоря, другой запрос:

```sql
SELECT DISTINCT `last`, `first`, `middle`, `dob`
FROM `20190307_2326_xc`
```

Возвращет 1944 записи (на 2 записи больше), что свидетельствует о том, что в редких случаях пациенты с одними и теми же ФИО и датой рождения могут иметь разные номера.

Выполнив запрос:

```sql
SELECT t1.`last`, t1.`first`, t1.`middle`, t1.`dob`, t1.`upi`, t2.`upi`
FROM `20190307_2326_xc` as t1 LEFT JOIN (SELECT `last`, `first`, `middle`, `dob`, `upi` FROM `20190307_2326_xc` GROUP BY `last`, `first`, `middle`, `dob`) as t2 ON `t1`.`upi` = `t2`.`upi`
WHERE t2.upi is null
GROUP BY t1.`last`, t1.`first`, t1.`middle`, t1.`dob`, t1.`upi`
```

Идентифицировал эти две записи.

Затем по фамилии я выбрал все связанные с ними записи, изучил, и стало ясно, что в обоих случаях это был один и тот же пациент, и заведение на них по два разных уникальных номера не было связано с тем, что это разные люди.

Таким образом, корректным видом группировки считаю ФИО и дату рождения, а корректным числом пациентов считаю 1942.

Так что результаты вышеуказанного запроса на 1942 экспортирую в CSV.

Добавляю в нем новое поле `id` и новое поле `trng` под случайные числа.

Теперь генерирую на RANDOM.ORG 1942 числа (`RANDOM.ORG - Integer Set Generator.html` прилагаю).

Заменяю запятую с пробелом на перенос строки.

Вставляю 1942 в поле под случайные числа — успешно.

Теперь создаю отдельную таблицу под авторов:

```sql
CREATE TABLE `20190307_2326_xc_1942` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `trng` int(11) NOT NULL,
  `last` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `first` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `middle` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `dob` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `upi` text COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

Импортировал — ОК.

Теперь запрос:

```sql
SELECT t2.`trng`, t1.*
FROM `20190307_2326_xc` as t1 LEFT JOIN `20190307_2326_xc_1942` as t2 ON t1.`last`=t2.`last` and t1.`first`=t2.`first` and t1.`middle`=t2.`middle` and t1.`dob`=t2.`dob`
ORDER BY t1.`spinality_type`, t2.`trng`, t1.`last`, t1.`first`, t1.`middle`
```

Готово.

Теперь загружаю из 1942 в «Новую запись».

При этом поле даты рождения сокращу до года, как необходимо, и объединю фамилию, имя и отчество через пробел в одно поле.

Внес. Временной штамп добавления (потребуется позднее): `09.03.19 04:08`.

Успешно загрузил 1942 в «Новую запись».

Теперь приступлю ко внесению из отсортированных 3940 в «Новую оценку».

Для этого там понадобится поле, содержащее ID соответствующей записи в «Новой записи».

Версию 3940 с этим полем удалось получить запросом:

```sql
SELECT t2.`submission_id`, t1.*
FROM `20190307_2326_xc` as t1 LEFT JOIN `ft_form_2` as t2 on t2.`name`=concat(t1.`last`," ",t1.`first`," ",t1.`middle`) and t2.`year`=year(t1.`dob`)
```

Перед этим пришлось перезагрузить в БД `20190307_2326_xc` наново, потому что там дата была в неправильном формате, и функция `year` ее не понимала. Заодно в поле `trng` для `20190307_2326_xc` внес уже правильные случайные числа.

В «Новую оценку» внести все поля не удалось, поскольку, похоже, был достигнут лимит.

Поэтому создаю новую форму (`ft_form_9`), которая просто будет ссылаться на «Новую запись».

Успешно перенес 3940 в эту форму.

Добавляю в нее редактируемые поля согласно d3f687421e73286defb56a46509ff76faa2b954a.

Упраздняю сложную группировку по группам записей и буду просто оценивать осложнения в пределах одного пациента, коль скоро такая группировка уже есть.

Соответственно «числовое поле для нумерации групп записей» — уже не нужно — не добавляю.

Итого нужно добавить 10 редактируемых полей.

Все добавил.

Можно приступать к заполнению.

Запрос на основную группу ВП:

```sql
SELECT *
FROM `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP '([Пп][Лл][Аа][Сс][Тт][Ии][Кк]|[Цц][Ее][Мм][Ее][Нн][Тт])' OR `icd10_code` REGEXP '([Пп][Лл][Аа][Сс][Тт][Ии][Кк]|[Цц][Ее][Мм][Ее][Нн][Тт])' OR `sx_name` REGEXP '([Пп][Лл][Аа][Сс][Тт][Ии][Кк]|[Цц][Ее][Мм][Ее][Нн][Тт])' OR `free_text` REGEXP '([Пп][Лл][Аа][Сс][Тт][Ии][Кк]|[Цц][Ее][Мм][Ее][Нн][Тт])' OR `col_34` REGEXP '([Пп][Лл][Аа][Сс][Тт][Ии][Кк]|[Цц][Ее][Мм][Ее][Нн][Тт])')
```

Я рассудил, что только в этих полях потенциально может содержаться соответствующая информация.

Поле `icd10_code` попало сюда, поскольку, как выяснилось, содержит не только код, но обычно и название нозологии по МКБ через пробел.

По непонятным причинам эти регвыры ни в какую не работают, поэтому пришлось заменить на типа `пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент`, которые работают:

```sql
SELECT *
FROM `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `icd10_code` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_name` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_postop_dx` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `free_text` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент')
```

Возвращает 105 записей.

Теперь необходимо добиться, чтобы факт вхождения по каждому из 4 регвыров отражался в самой записи в `ft_form_9`.

Для этого там потребуется еще 4 поля, которые сейчас добавлю — добавил.

Таким образом, структура `ft_form_9` сейчас:

```sql
CREATE TABLE `ft_form_9` (
  `submission_id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
  `record_id` varchar(255) DEFAULT NULL,
  `id_3490` varchar(255) DEFAULT NULL,
  `trng` mediumint(8) unsigned NOT NULL,
  `mrn` varchar(255) DEFAULT NULL,
  `upi` varchar(255) DEFAULT NULL,
  `last` varchar(255) DEFAULT NULL,
  `first` varchar(255) DEFAULT NULL,
  `middle` varchar(255) DEFAULT NULL,
  `sex` varchar(255) DEFAULT NULL,
  `dob` varchar(255) DEFAULT NULL,
  `doa` varchar(255) DEFAULT NULL,
  `dod` varchar(255) DEFAULT NULL,
  `note_specialty` varchar(255) DEFAULT NULL,
  `note_type` varchar(255) DEFAULT NULL,
  `note_text` text,
  `phone_home` varchar(255) DEFAULT NULL,
  `phone_mobile` varchar(255) DEFAULT NULL,
  `phone_comment` varchar(255) DEFAULT NULL,
  `registration_address` varchar(255) DEFAULT NULL,
  `home_address` varchar(255) DEFAULT NULL,
  `icd10_code` varchar(255) DEFAULT NULL,
  `ward_field` varchar(255) DEFAULT NULL,
  `sx_code` varchar(255) DEFAULT NULL,
  `sx_date` varchar(255) DEFAULT NULL,
  `sx_asa` varchar(255) DEFAULT NULL,
  `sx_acuteness` varchar(255) DEFAULT NULL,
  `sx_name` varchar(255) DEFAULT NULL,
  `sx_type` varchar(255) DEFAULT NULL,
  `sx_timing` varchar(255) DEFAULT NULL,
  `sx_an_type` varchar(255) DEFAULT NULL,
  `sx_an_start` varchar(255) DEFAULT NULL,
  `sx_an_end` varchar(255) DEFAULT NULL,
  `sx_postop_dx` varchar(255) DEFAULT NULL,
  `free_text` text,
  `spinality_type` varchar(255) DEFAULT NULL,
  `submission_date` datetime NOT NULL,
  `last_modified_date` datetime NOT NULL,
  `ip_address` varchar(15) DEFAULT NULL,
  `is_finalized` enum('yes','no') DEFAULT 'yes',
  `relevance1` varchar(255) DEFAULT NULL,
  `relevance2` varchar(255) DEFAULT NULL,
  `relevance3` varchar(255) DEFAULT NULL,
  `relevance4` varchar(255) DEFAULT NULL,
  `arm1` varchar(255) DEFAULT NULL,
  `arm2` varchar(255) DEFAULT NULL,
  `arm3` varchar(255) DEFAULT NULL,
  `arm4` varchar(255) DEFAULT NULL,
  `ae_bool` varchar(255) DEFAULT NULL,
  `ae_text` varchar(255) DEFAULT NULL,
  `regex1` varchar(255) DEFAULT NULL,
  `regex2` varchar(255) DEFAULT NULL,
  `regex3` varchar(255) DEFAULT NULL,
  `regex4` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`submission_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

Предназначение всех полей должно быть понятно с учетом уже написанного в журнале и d3f687421e73286defb56a46509ff76faa2b954a.

Поля с `regex1` по `regex4` — и есть те самые поля, куда буду сейчас записывать факт вхождения, в FormTools они представлены нередактируемыми полями-переключателеми (Да / Нет / Не выбрано; что соответствует значениям поля: 1 / 0 / NA).

Сгруппировал я поля, преследуя максимальное удобство заполнения, на одной вкладке следующим образом (копипаста из FormTools; там машинный перевод интерфейса на русский, так что на «Заказ» и «Свидание» внимания не обращать):

```
ЗаказПолеТип поляEditableПоиск
1ОсложненияПереключатели 
2Другое осложнениеТекстовое поле 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по ВППереключатели 
2Релевантность по ВППереключатели 
3Группа по ВППереключатели 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по деформациямПереключатели 
2Релевантность по деформациямПереключатели 
3Группа по деформациямПереключатели 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по ДДЗП ШОППереключатели 
2Релевантность по ДДЗП ШОППереключатели 
3Группа по ДДЗП ШОППереключатели 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по инфекциямПереключатели 
2Релевантность по инфекциямПереключатели 
3Группа по инфекциямПереключатели 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1IDТекстовое поле
2ЗаписьRecord Picker 
3ID из 3940Текстовое поле 
4TRNG для xa-led-p1m-aprТекстовое поле 
5№ ИБТекстовое поле 
6Комп. номер пациентаТекстовое поле 
7ФамилияТекстовое поле 
8ИмяТекстовое поле 
9ОтчествоТекстовое поле 
10ПолТекстовое поле 
11Дата рожденияТекстовое поле 
12Дата поступленияТекстовое поле 
13Дата выпискиТекстовое поле 
14Вид осмотраТекстовое поле 
15Тип осмотраТекстовое поле 
16Протокол осмотраTextarea 
17Телефон дом.Текстовое поле 
18Телефон сот.Текстовое поле 
19КомментарийТекстовое поле 
20Адрес регистрацииТекстовое поле 
21Адрес проживанияТекстовое поле 
22Диагноз по МКБ-10Текстовое поле 
23поле-индикатор пребывания на отделенияхТекстовое поле 
24Код операцииТекстовое поле 
25Дата операцииТекстовое поле 
26ASAТекстовое поле 
27Экстренная/ плановаяТекстовое поле 
28Полное наименование операцииТекстовое поле 
29Тип операцииТекстовое поле 
30Часов от момента поступленияТекстовое поле 
31Вид обезболиванияТекстовое поле 
32Начало наркозаТекстовое поле 
33Окончание наркозаТекстовое поле 
34Послеоперационный диагнозТекстовое поле 
35Описание операции/КТ/МРТTextarea 
36Вид спинальностиТекстовое поле 
37СвиданиеСвидание 
38ИзмененСвидание
39IP-адресТекстовое поле 
Добавить поле (ы) »
```

Немного сейчас абстрагируясь, поясню, каким образом сейчас представляю себе процесс заполнения:

* Есть 3940 записей в `ft_form_9` и соответствующая форма в FormTools.
* Записи в форме по умолчанию отсортированы возрастанию по `trng`, то есть записи, относящиеся к одному пациенту (с совпадающими ФИО и годом рождения), идут вместе, группами, при этом сами эти группы идут в случайном порядке.
* Я беру и просматриваю поочередно каждую запись и смотрю, что у нее стоит в полях вхождения по регвырам (эти поля сейчас как раз предстоит заполнить, к чему я вернусь, как только опишу процесс заполнения).
* Если есть совпадение по какому-то из регвыров, то изучаю эту запись на предмет релевантности данного вхождения (если имеется вхождение сразу по нескольким регвырам, то, соответственно, я оцениваю релевантность каждого из вхождений), пользуясь разделом о популяции соответствующего протокола (см. именные ветки xa-led-p1m-apr-conference).
* Если по какому-либо из вхождений я принимаю решение, что запись релевантна, то проставляю соответствующую пометку в эту запись (опять-таки если я принимаю решение о релевантности сразу по нескольким вхождениям, то и отмечаю это соответственно).
* ~~И если запись релевантна, то я проставляю пометку о включении ее в основную группу по соответствующему протоколу; по идее, пометку о вхождении в основную группу я должен проставить и для всех прилежащих записей, относящихся к этому пациенту, однако поскольку все записи, относящиеся к одному пациенту, можно однозначно идентифицировать, то и достаточно будет, чтобы такая пометка стояла хотя бы для одной из них, и поэтому не нужно с этим заморачиваться — главным будет не забыть учесть это, когда буду запрашивать из базы количество пациентов и записей, входящих в основную и контрольную группы.~~ Кстати говоря, даже этого делать не нужно, коль скоро факт релевантности с необходимостью определяет факт вхождения в основную группу. Так что и не буду этого делать. Принадлежность же к группе сравнения следует заполнить автоматически, см. ниже.
* Затем, если запись релевантна, я просматриваю все прилежащие записи, относящиеся к этому пациенту, чтобы определить, имеются ли здесь признаки осложнений, и это я делаю согласно разделу о методах получения данных из базы в соответствующем протоколе, а поскольку этот раздел в части классификации осложнений во всех этих протоколах — одинаковый, то можно сразу сказать еще более конкретно: буду это делать, следуя шагам 2 и 3 в [[@Rampersaud2016]](https://pubmed.gov/27058499), и при выявлении осложнений буду помечать это в соответствующем поле (кстати, в d3f687421e73286defb56a46509ff76faa2b954a мы почему-то «предполагаем, что между всеми четырьмя работами не будет ни одной пересекающейся группы», и поэтому, мол, будет достаточно двух полей: `ae_bool` и `ae_text`,— а сейчас я в упор не вижу, чтобы предположение об отсутствии пересечений было обоснованно, так что полей все же понадобится восемь: по одному на каждую работу; сейчас добавлю), а если единственным осложнением, которое я вижу по пациенту, являтся «Другое», то буду вписывать это осложнение в соответствующее поле.

    Добавил недостающие поля, вот так теперь выглядит копипаста из FormTools:

    ```
    ЗаказПолеТип поляEditableПоиск
    1Вхождение по регвыру по ВППереключатели 
    2Релевантность по ВППереключатели 
    3Группа по ВППереключатели 
    4Наличие осложнений по ВППереключатели 
    5Другие осложнения по ВПТекстовое поле 
    Добавить поле (ы) »

    ЗаказПолеТип поляEditableПоиск
    1Вхождение по регвыру по деформациямПереключатели 
    2Релевантность по деформациямПереключатели 
    3Группа по деформациямПереключатели 
    4Наличие осложнений по деформациямПереключатели 
    5Другие осложнения по деформациямТекстовое поле 
    Добавить поле (ы) »

    ЗаказПолеТип поляEditableПоиск
    1Вхождение по регвыру по ДДЗП ШОППереключатели 
    2Релевантность по ДДЗП ШОППереключатели 
    3Группа по ДДЗП ШОППереключатели 
    4Наличие осложнений по ДДЗП ШОППереключатели 
    5Другие осложнения по ДДЗП ШОПТекстовое поле 
    Добавить поле (ы) »

    ЗаказПолеТип поляEditableПоиск
    1Вхождение по регвыру по инфекциямПереключатели 
    2Релевантность по инфекциямПереключатели 
    3Группа по инфекциямПереключатели 
    4Наличие осложнений по инфекциямПереключатели 
    5Другие осложнения по инфекциямТекстовое поле 
    Добавить поле (ы) »

    ЗаказПолеТип поляEditableПоиск
    1IDТекстовое поле
    2ЗаписьRecord Picker 
    3ID из 3940Текстовое поле 
    4TRNG для xa-led-p1m-aprТекстовое поле 
    5№ ИБТекстовое поле 
    6Комп. номер пациентаТекстовое поле 
    7ФамилияТекстовое поле 
    8ИмяТекстовое поле 
    9ОтчествоТекстовое поле 
    10ПолТекстовое поле 
    11Дата рожденияТекстовое поле 
    12Дата поступленияТекстовое поле 
    13Дата выпискиТекстовое поле 
    14Вид осмотраТекстовое поле 
    15Тип осмотраТекстовое поле 
    16Протокол осмотраTextarea 
    17Телефон дом.Текстовое поле 
    18Телефон сот.Текстовое поле 
    19КомментарийТекстовое поле 
    20Адрес регистрацииТекстовое поле 
    21Адрес проживанияТекстовое поле 
    22Диагноз по МКБ-10Текстовое поле 
    23поле-индикатор пребывания на отделенияхТекстовое поле 
    24Код операцииТекстовое поле 
    25Дата операцииТекстовое поле 
    26ASAТекстовое поле 
    27Экстренная/ плановаяТекстовое поле 
    28Полное наименование операцииТекстовое поле 
    29Тип операцииТекстовое поле 
    30Часов от момента поступленияТекстовое поле 
    31Вид обезболиванияТекстовое поле 
    32Начало наркозаТекстовое поле 
    33Окончание наркозаТекстовое поле 
    34Послеоперационный диагнозТекстовое поле 
    35Описание операции/КТ/МРТTextarea 
    36Вид спинальностиТекстовое поле 
    37СвиданиеСвидание 
    38ИзмененСвидание
    39IP-адресТекстовое поле 
    ```

    И вот так теперь выглядит структура `ft_form_9`:

    ```sql
        CREATE TABLE `ft_form_9` (
    `submission_id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
    `record_id` varchar(255) DEFAULT NULL,
    `id_3490` varchar(255) DEFAULT NULL,
    `trng` mediumint(8) unsigned NOT NULL,
    `mrn` varchar(255) DEFAULT NULL,
    `upi` varchar(255) DEFAULT NULL,
    `last` varchar(255) DEFAULT NULL,
    `first` varchar(255) DEFAULT NULL,
    `middle` varchar(255) DEFAULT NULL,
    `sex` varchar(255) DEFAULT NULL,
    `dob` varchar(255) DEFAULT NULL,
    `doa` varchar(255) DEFAULT NULL,
    `dod` varchar(255) DEFAULT NULL,
    `note_specialty` varchar(255) DEFAULT NULL,
    `note_type` varchar(255) DEFAULT NULL,
    `note_text` text,
    `phone_home` varchar(255) DEFAULT NULL,
    `phone_mobile` varchar(255) DEFAULT NULL,
    `phone_comment` varchar(255) DEFAULT NULL,
    `registration_address` varchar(255) DEFAULT NULL,
    `home_address` varchar(255) DEFAULT NULL,
    `icd10_code` varchar(255) DEFAULT NULL,
    `ward_field` varchar(255) DEFAULT NULL,
    `sx_code` varchar(255) DEFAULT NULL,
    `sx_date` varchar(255) DEFAULT NULL,
    `sx_asa` varchar(255) DEFAULT NULL,
    `sx_acuteness` varchar(255) DEFAULT NULL,
    `sx_name` varchar(255) DEFAULT NULL,
    `sx_type` varchar(255) DEFAULT NULL,
    `sx_timing` varchar(255) DEFAULT NULL,
    `sx_an_type` varchar(255) DEFAULT NULL,
    `sx_an_start` varchar(255) DEFAULT NULL,
    `sx_an_end` varchar(255) DEFAULT NULL,
    `sx_postop_dx` varchar(255) DEFAULT NULL,
    `free_text` text,
    `spinality_type` varchar(255) DEFAULT NULL,
    `submission_date` datetime NOT NULL,
    `last_modified_date` datetime NOT NULL,
    `ip_address` varchar(15) DEFAULT NULL,
    `is_finalized` enum('yes','no') DEFAULT 'yes',
    `relevance1` varchar(255) DEFAULT NULL,
    `relevance2` varchar(255) DEFAULT NULL,
    `relevance3` varchar(255) DEFAULT NULL,
    `relevance4` varchar(255) DEFAULT NULL,
    `arm1` varchar(255) DEFAULT NULL,
    `arm2` varchar(255) DEFAULT NULL,
    `arm3` varchar(255) DEFAULT NULL,
    `arm4` varchar(255) DEFAULT NULL,
    `ae_bool_1` varchar(255) DEFAULT NULL,
    `ae_text_2` varchar(255) DEFAULT NULL,
    `regex1` varchar(255) DEFAULT NULL,
    `regex2` varchar(255) DEFAULT NULL,
    `regex3` varchar(255) DEFAULT NULL,
    `regex4` varchar(255) DEFAULT NULL,
    `ae_bool_2` varchar(255) DEFAULT NULL,
    `ae_bool_3` varchar(255) DEFAULT NULL,
    `ae_bool_4` varchar(255) DEFAULT NULL,
    `ae_text_1` varchar(255) DEFAULT NULL,
    `ae_text_3` varchar(255) DEFAULT NULL,
    `ae_text_4` varchar(255) DEFAULT NULL,
    PRIMARY KEY (`submission_id`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    ```

* Вообще для простоты проставлю-ка я лучше в поле `is_finalized` значение `NULL` для всех записей, у которых не будет ни одного вхождения: в этом случае FormTools перестанет их видеть. Сделаю, как только заполню все четыре поля о факте вхождения.
* После того, как я полностью закончу просмотр всех записей, займусь контрольной группой.
* Для этого выясню и документирую количество записей и _пациентов_, определенных мной как релевантные по каждому из четырех протоколов, после чего сделаю следующее.
* Возьму все записи «Спинальная КТ», отсортирую их по `trng` и сгруппирую по `record_id` (поле, содержащее ссылку на запись в таблице «Новая запись» — грубо говоря, сгруппирую по ФИО и году рождения). Получу таким образом выдачу и число пациентов в рубрике «Спинальная КТ» (кстати, документирую это, а также проделаю то же самое для «Спинальная операция»: сугубо для дескриптивных статистик, ведь у нас есть общее число записей и число записей по каждому типу спинальности, а по пациентам есть только общее число).
* Из этих записей выберу первые столько же, сколько у нас релевантных пациентов по каждому из протоколов, то есть сделаю четыре запроса, и выборки эти куда-нибудь сохраню.
* Затем сделаю четыре INSERT INTO в `ft_form_9`, проставив в соответствующее данному протоколу поле для принадлежности к группе (с `arm1` по `arm4`) значение `0` (контрольная группа) для всех таких записей, которые ссылаются на этих пациентов. Таким образом мы получим для каждого протокола в качестве контрольной группы случайную подборку из «Спинальная КТ» такого же размера (если судить по числу пациентов, конечно, а не записей), как и основная группа.
* Для полной идиллии проставлю автоматически для всех релевантных записей по каждому из протоколов в соответствующее данному протоколу поле для принадлежности к группе (с `arm1` по `arm4`) значение `1` (основная группа).
* Затем сделаю INSERT INTO в `ft_form_9`, проставив в поле `is_finalized` значение `yes` для всех записей из контрольных групп. Таким образом все записи, включенные в контрольные группы, станут отображаться в FormTools.
* Дальше проведу классификацию осложнений в контрольной группе совершенно аналогично этому процессу для основной группы.
* Ну, и по завершении классификации осложнений для всех записей в контрольной группе процесс переноса будет завершен. Останется запросить из базы все числа, необходимые для анализа (буду смотреть [раздел о методах анализа в общем протоколе](#методы-трансформации-и-анализа-данных): он одинаковый для всех частных протоколов, а в общем протоколе мы также добавили NNH).
* Еще раз резюмирую, что по итогу редактируемыми получаются всего ~~8~~ 12 полей: бинарное поле о наличии или отсутствии осложнений и короткое текстовое поле для осложнений «Другое» — два поля для каждого из четырех протоколов, а также четыре поля для определения релевантности. Все остальные поля я заполню автоматически.

Приступаю к заполнению поля о наличии вхождения по регвыру по ВП:

```sql
UPDATE `ft_form_9`
SET `regex1` = 1
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `icd10_code` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_name` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_postop_dx` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `free_text` REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент')
```

Готово.

И нет вхождения, если не совпадает по регвыру:

Сначала проверю селектом:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `spinality_type` = 'Спинальная КТ' OR `spinality_type` = 'Спинальная МРТ' OR (`spinality_type` = 'Спинальная операция' AND `note_text` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' AND `icd10_code` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' AND `sx_name` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' AND `sx_postop_dx` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' AND `free_text` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент');
```

Возвратил 3414 вместо 3835 — что-то не то.

Все ясно: проблема была в ~~collation~~ том, что не считал `NULL` записи ([«If either expr or pat is NULL, the return value is NULL»](https://dev.mysql.com/doc/refman/5.5/en/regexp.html)).

В такой вариации:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `spinality_type` = 'Спинальная КТ' OR `spinality_type` = 'Спинальная МРТ' OR (`spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `free_text` IS NULL))
```

Возвращает ожидаемые 3835.

Ну и апдейт:

Для «Спинальных операций»:

```sql
UPDATE `ft_form_9`
SET `regex1` = 0
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'пластик|ПЛАСТИК|Пластик|Цемент|ЦЕМЕНТ|цемент' OR `free_text` IS NULL)
```

Готово, обновил 541 запись.

Для «Спинальных КТ/МРТ» (для них обоснованней `NA`, коль скоро по ним вообще искать не планировали):

```sql
UPDATE `ft_form_9`
SET `regex1` = 'NA', `regex2` = 'NA', `regex3` = 'NA', `regex4` = 'NA'
WHERE `spinality_type` = 'Спинальная КТ' OR `spinality_type` = 'Спинальная МРТ'
```

Готово, обновил 3294 записи.

Проверяю в FormTools: успешно отображаются значения по «Вхождение по регвыру по ВП».

Далее проделаю аналогичным образом для оставшихся трех регвыров, буду документировать только запросы и количества записей.

Приступаю к заполнению поля о наличии вхождения по регвыру по деформациям:

Сначала проверю селектом:

```sql
SELECT COUNT(*)
FROM `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `icd10_code` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_name` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_postop_dx` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `free_text` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио')
```

Возвращает 69.

Ну и апдейт:

```sql
UPDATE `ft_form_9`
SET `regex2` = 1
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `icd10_code` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_name` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_postop_dx` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `free_text` REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио')
```

Готово: обновил 69 записей.

И нет вхождения, если не совпадает по регвыру:

Сначала проверю селектом:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `free_text` IS NULL)
```

Возвращает ожидаемые 577.

Ну и апдейт:

Для «Спинальных операций»:

```sql
UPDATE `ft_form_9`
SET `regex2` = 0
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'деформац|ДЕФОРМАЦ|Деформац|кифо|КИФО|Кифо|лордо|ЛОРДО|Лордо|сколио|СКОЛИО|Сколио' OR `free_text` IS NULL)
```

Готово, обновил 577 записей.

Проверяю в FormTools: успешно отображаются значения по «Вхождение по регвыру по деформациям».

Приступаю к заполнению поля о наличии вхождения по регвыру по ДДЗП ШОП:

Сначала проверю селектом (обратить внимание, что в [CcСс] добавил заглавную латинскую C, поскольку модификатор `i` же здесь не указать для оператора REGEXP в MySQL):

```sql
SELECT COUNT(*)
FROM `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `icd10_code` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_name` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_postop_dx` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `free_text` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул')
```

Возвращает 367.

Учитывая опыт муток с регвыром выше проверю-ка еще отдельно регвыр на `C1—C8`:

```sql
SELECT COUNT(*)
FROM `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP '[CcСс][12345678]' OR `icd10_code` REGEXP '[CcСс][12345678]' OR `sx_name` REGEXP '[CcСс][12345678]' OR `sx_postop_dx` REGEXP '[CcСс][12345678]' OR `free_text` REGEXP '[CcСс][12345678]')
```

Ну, возвращает какие-то 139. ОК.

Апдейт:

```sql
UPDATE `ft_form_9`
SET `regex3` = 1
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `icd10_code` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_name` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_postop_dx` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `free_text` REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул')
```

Готово: обновил 367 записей.

И нет вхождения, если не совпадает по регвыру:

Сначала проверю селектом:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `free_text` IS NULL)
```

Возвращает ожидаемые 279.

Апдейт:

```sql
UPDATE `ft_form_9`
SET `regex3` = 0
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'шей|ШЕЙ|Шей|[CcСс][12345678]|миело|МИЕЛО|Миело|радикул|РАДИКУЛ|Радикул' OR `free_text` IS NULL)
```

Готово, обновил 279 записей.

Проверяю в FormTools: успешно отображаются значения по «Вхождение по регвыру по ДДЗП ШОП».

Приступаю к заполнению поля о наличии вхождения по регвыру по инфекциям.

Сначала проверю селектом (обратить внимание, что в [CcСс] добавил заглавную латинскую C, поскольку модификатор `i` же здесь не указать для оператора REGEXP в MySQL):

```sql
SELECT COUNT(*)
FROM `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `icd10_code` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_name` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_postop_dx` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `free_text` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце')
```

Возвращает 60.

Апдейт:

```sql
UPDATE `ft_form_9`
SET `regex4` = 1
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `icd10_code` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_name` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_postop_dx` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `free_text` REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце')
```

Готово: обновил 60 записей.

И нет вхождения, если не совпадает по регвыру:

Сначала проверю селектом:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `free_text` IS NULL)
```

Возвращает ожидаемые 586.

Апдейт:

```sql
UPDATE `ft_form_9`
SET `regex4` = 0
WHERE `spinality_type` = 'Спинальная операция' AND (`note_text` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `note_text` IS NULL) AND (`icd10_code` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `icd10_code` IS NULL) AND (`sx_name` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_name` IS NULL) AND (`sx_postop_dx` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `sx_postop_dx` IS NULL) AND (`free_text` NOT REGEXP 'спондилит|СПОНДИЛИТ|Спондилит|дисцит|ДИСЦИТ|Дисцит|остеомиелит|ОСТЕОМИЕЛИТ|Остеомиелит|абсце|АБСЦЕ|Абсце' OR `free_text` IS NULL)
```

Готово, обновил 586 записей.

Проверяю в FormTools: успешно отображаются значения по «Вхождение по регвыру по инфекциям».

Проверю, не осталось ли пустых записей по любому из полей с `regex1` по `regex4`:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex1` IS NULL OR `regex2` IS NULL OR `regex3` IS NULL OR `regex4` IS NULL
```

Возращает ожидаемый ноль.

Итак, все вхождения внес в базу.

Резюмирую (не устану благодарить [Tables Generator](https://www.tablesgenerator.com/markdown_tables)!):

| Протокол   | Регулярное выражение                                                                                       | Имеют вхождение, записи | Не имеют вхождений, записи | Итого записей                       |
|------------|------------------------------------------------------------------------------------------------------------|-------------------------|----------------------------|-------------------------------------|
| ВП         | пластик&#10072;ПЛАСТИК&#10072;Пластик&#10072;Цемент&#10072;ЦЕМЕНТ&#10072;цемент                                                             | 105                     | 541                        | 646                                 |
| Деформации | деформац&#10072;ДЕФОРМАЦ&#10072;Деформац&#10072;кифо&#10072;КИФО&#10072;Кифо&#10072;лордо&#10072;ЛОРДО&#10072;Лордо&#10072;сколио&#10072;СКОЛИО&#10072;Сколио                         | 69                      | 577                        | 646                                 |
| ДДЗП ШОП   | шей&#10072;ШЕЙ&#10072;Шей&#10072;[CcСс][12345678]&#10072;миело&#10072;МИЕЛО&#10072;Миело&#10072;радикул&#10072;РАДИКУЛ&#10072;Радикул                                   | 367                     | 279                        | 646                                 |
| Инфекции   | спондилит&#10072;СПОНДИЛИТ&#10072;Спондилит&#10072;дисцит&#10072;ДИСЦИТ&#10072;Дисцит&#10072;остеомиелит&#10072;ОСТЕОМИЕЛИТ&#10072;Остеомиелит&#10072;абсце&#10072;АБСЦЕ&#10072;Абсце | 60                      | 586                        | 646                                 |
| Всего      | —                                                                                                          | 484                     | 3456                       | 3946                                |

Ну и посмотрю то же по пациентам (заодно и по типу спинальности посчитаю пациентов, потому что до этого считал только записи):

* Число пациентов еще раз — пересчитаю так как выше расчет был по группировке: одинаковые ФИО и дата рождения (к тому же в другой таблице),— и убежусь, что число по группировке по году рождения остается таким же.

    На всякий случай поясняю, что _дата_ рождения превратилась в _год_ рождения, когда я добавлял к 3940 „поле, содержащее ID соответствующей записи в «Новой записи»“ (см. это словосочетание выше по тексту).

    Итак, запрос:

    ```sql
    SELECT COUNT(*) FROM
    (
        SELECT COUNT(*)
        FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
        GROUP BY t2.`name`, t2.`year`
    ) t3
    ```

    Возвращает то же число, 1942.

* Число пациентов по типу спинальности:

    «Спинальная операция»:

    ```sql
    SET @spinalityType = 'Спинальная операция';

    SELECT COUNT(*) FROM
    (
        SELECT COUNT(*)
        FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
        WHERE t1.`spinality_type` = @spinalityType
        GROUP BY t2.`name`, t2.`year`
    ) t3
    ```

    Возвращает 571.

    «Спинальная КТ/МРТ:

    ```sql
    SET @spinalityType1 = 'Спинальная КТ';
    SET @spinalityType2 = 'Спинальная МРТ';

    SELECT COUNT(*) FROM
    (
        SELECT COUNT(*)
        FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
        WHERE t1.`spinality_type` = @spinalityType1 OR t1.`spinality_type` = @spinalityType2
        GROUP BY t2.`name`, t2.`year`
    ) t3
    ```

    Возвращает 1413 вместо ожидаемых 1371.

    Ага, понятно: это за счет того, что ряд пациентов имеют смешанный тип спинальности.

    Это подтверждается тем, что добавление к полями группировки кроме ФИО и года рождения также типа спинальности:

    ```sql
    SELECT COUNT(*) FROM
    (
        SELECT COUNT(*)
        FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
        GROUP BY t2.`name`, t2.`year`, t1.`spinality_type`
    ) t3
    ```

    Возвращает 1984, а 1984 = 571 + 1413 (на 42 больше).

    Поэтому определю выделю число пациентов со смешанным типом спинальности среди 571 и среди 1413:

    ```sql
    SELECT t3a.`spinality_type`, COUNT(*)
    FROM
     (
        SELECT t1a.`submission_id`, t1a.`spinality_type`, COUNT(*)
        FROM `ft_form_9` t1a LEFT JOIN `ft_form_2` t2a ON t1a.`record_id` = t2a.`submission_id`
        GROUP BY t2a.`name`, t2a.`year`, t1a.`spinality_type`
    ) t3a LEFT JOIN
    (
        SELECT t1b.`submission_id`, COUNT(*)
        FROM `ft_form_9` t1b LEFT JOIN `ft_form_2` t2b ON t1b.`record_id` = t2b.`submission_id`
        GROUP BY t2b.`name`, t2b.`year`
    ) t3b ON t3a.`submission_id` = t3b.`submission_id`
    WHERE t3b.`submission_id` IS NULL
    GROUP BY t3a.`spinality_type`
    ```

    Возвращает 20 (Спинальная операция) и 22 (Спинальная КТ), итого ожидаемые 42.

    Значит необходимо скорректировать полученные 571 и 1413: 571 включают 551 и 1391 соответственно, итого ~~ожидаемые 1942~~ — что? Какие же они ожидаемые! 1942 — это все пациенты, вместе взятые, а значит 551 и 1391 не могут правильными количествами пациентов с типами спинальности «Спинальная операция» и «Спинальная КТ/МРТ» (не могут быть как раз потому, что еще часть пациентов имеют смешанный тип, а 551 плюс 1391 уже равно 1942).

    И ответ вот где: каждая запись из 20 (Спинальная операция) имеет смешанный тип спинальности, а значит ей соответствует еще одна зеркальная запись (с типом спинальности «Спинальная КТ») среди тех, что были отброшены при выполнении условия `WHERE t3b.`submission_id` IS NULL`.

    Аналогичным образом, каждой записи из 22 (Спинальная КТ) соответствует еще одна зеркальная запись (с типом спинальности «Спинальная операция») среди тех, что были отброшены при выполнении условия `WHERE t3b.`submission_id` IS NULL`.

    Таким образом, реальное число пациентов с типом спинальности «Спинальная операция»:

    > 571 - 20 * 2 = 531.

    Аналогичным образом, реальное число пациентов с типом спинальности «Спинальная операция»:

    > 1413 - 22 * 2 = 1369.

    Наконец, реальное число пациентов со смешанным типом спинальности:

    > 1942 - 531 - 1369 = 42.

    Ф-фух.

Итак, полная структура выборки по спинальности:

| Категория                              | Число записей | Число пациентов (записей с разными ФИО и годом рождения) |
|----------------------------------------|---------------|----------------------------------------------------------|
| Всего                                  | 3940          | 1942                                                     |
| Всего после удаления 100%-х дубликатов | 3940          | —                                                        |
| Спинальная операция                    | 646           | 531                                                      |
| Спинальная КТ                          | 3294          | 1369                                                     |
| Спинальная МРТ                         | 0             | 0                                                        |
| Смешанная спинальность                 | —             | 42                                                       |

Отключаю отображение полей без вхождений в FormTools:

Сначала проверю селектом:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex1` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex2` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex3` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex4` != 1
```

Возвращает ~~ожидаемые 105, 69, 367 и 60~~ 3835, 3871, 3573 и 3880.

Очевидно, это опять шалят `NULL`.

Значит так запрошу:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex1` IS NULL OR `regex1` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex2` IS NULL OR `regex2` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex3` IS NULL OR `regex3` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex4` IS NULL OR `regex4` != 1
```

Странновато, конечно, немножко выглядит это `a IS NULL OR a != x`, ну да ладно.

Ха, а возвращает-то все те же самые 3835, 3871, 3573 и 3880.

Смотрю в таблицу: ха, а действительно! `NULL` здесь не причем. У нас ведь `NA` еще есть!

Тогда переписываю первый вариант запроса, без `NULL`:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex1` = 'NA' OR `regex1` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex2` = 'NA' OR `regex2` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex3` = 'NA' OR `regex3` != 1
UNION ALL
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex4` = 'NA' OR `regex4` != 1
```

Ха, и возвращает-то все те же самые 3835, 3871, 3573 и 3880.

Ха, конечно, баклажан: `regex3 != 1` и так учитывает `NA`.

Все просто: 3835, 3871, 3573 и 3880 — и есть ожидаемые значения для полей _без_ вхождений, а не 105, 69, 367 и 60, которые как раз для полей с вхождениями.

Значит ОК.

Тогда апдейт:

```sql
UPDATE `ft_form_9`
SET `is_finalized` = NULL
WHERE `regex1` != 1 OR `regex2` != 1 OR `regex3` != 1 OR `regex4` != 1
```

ОК, обновлены ожидаемые… а сколько ожидаемые? Общее число записей со вхождениями-то я не считал.

Сейчас посчитаю:

```sql
SELECT COUNT(*)
FROM  `ft_form_9`
WHERE `regex1` = 1 OR `regex2` = 1 OR `regex3` = 1 OR `regex4` = 1
```

Возвращает 484.

Итак, всего 484 записи со вхождениями, а значит всего 3456 записей без вхождений.

Добавлю строчку в таблицу выше.

И, кстати, в той таблице форматирование поехало ~~за счет того, что регулярки с вертикальной чертой не обособил обратным апострофом — тоже заодно исправляю~~. Обратные апострофы не спасли — пришлось заменить вертикальные черты в регулярках HTML-кодом этого символа (`&#10072;`).

А еще я забыл же посчитать число пациентов по вхождениям — тоже сейчас сделаю.

Но сначала заканчиваю апдейт:

```sql
UPDATE `ft_form_9`
SET `is_finalized` = NULL
WHERE `regex1` != 1 OR `regex2` != 1 OR `regex3` != 1 OR `regex4` != 1
```

ОК, обновлены ~~ожидаемые 3456 записей~~ все 3940 записей.

Ну да, вообще-то логично с таким `WHERE`.

Возвращаю `is_finalized` назад на `yes`:

```sql
UPDATE `ft_form_9`
SET `is_finalized` = 'yes'
```

ОК. И теперь булево корректный апдейт:

```sql
UPDATE `ft_form_9`
SET `is_finalized` = NULL
WHERE `regex1` != 1 AND `regex2` != 1 AND `regex3` != 1 AND `regex4` != 1
```

ОК, вот теперь наконец обновлены ожидаемые 3456 записей.

Проверяю в FormTools: теперь вместо 3940 отображаются только ожидаемые 484 записи.

Сейчас еще дорезюмирую по вхождениям по пациентам и перейду к определению релевантности.

(Забекаплю-ка кстати тоже БД заодно — готово.)

Запрос на число пациентов со вхождениями:

```sql
SET @regex1ProtocolLabel = 'ВП';
SET @regex2ProtocolLabel = 'Деформации';
SET @regex3ProtocolLabel = 'ДДЗП ШОП';
SET @regex4ProtocolLabel = 'Инфекции';
SET @totalLabel = 'Всего';

SELECT @regex1ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex1` = 1
    GROUP BY t2.`name`, t2.`year`
) t3_regex1
UNION ALL
SELECT @regex2ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex2` = 1
    GROUP BY t2.`name`, t2.`year`
) t3_regex2
UNION ALL
SELECT @regex3ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex3` = 1
    GROUP BY t2.`name`, t2.`year`
) t3_regex3
UNION ALL
SELECT @regex4ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex4` = 1
    GROUP BY t2.`name`, t2.`year`
) t3_regex4
UNION ALL
SELECT @totalLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex1` = 1 OR t1.`regex2` = 1 OR t1.`regex3` = 1 OR t1.`regex4` = 1
    GROUP BY t2.`name`, t2.`year`
) t3_total
```

ОК:

```
@regex1ProtocolLabel	COUNT(*)
ВП	100
Деформации	62
ДДЗП ШОП	343
Инфекции	46
Всего	442
```

Пациентов без вхождений (по регвырам — среди тех, по кому искали: среди «Спинальная операция» только; общее количество — по всем пациентам: «Спинальная операция» плюс смешанная спинальность):

```sql
SET @regex1ProtocolLabel = 'ВП';
SET @regex2ProtocolLabel = 'Деформации';
SET @regex3ProtocolLabel = 'ДДЗП ШОП';
SET @regex4ProtocolLabel = 'Инфекции';
SET @totalLabel = 'Всего';

SELECT @regex1ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex1` IS NOT NULL AND t1.`regex1` = 0
    GROUP BY t2.`name`, t2.`year`
) t3_regex1
UNION ALL
SELECT @regex2ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex2` = 0
    GROUP BY t2.`name`, t2.`year`
) t3_regex2
UNION ALL
SELECT @regex3ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex3` = 0
    GROUP BY t2.`name`, t2.`year`
) t3_regex3
UNION ALL
SELECT @regex4ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex4` = 0
    GROUP BY t2.`name`, t2.`year`
) t3_regex4
UNION ALL
SELECT @totalLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex1` != 1 AND t1.`regex2` != 1 AND t1.`regex3` != 1 AND t1.`regex4` != 1
    GROUP BY t2.`name`, t2.`year`
) t3_total
```

~~ОК: возвратил ожидаемые:~~ Нет, не возвратил.

```
@regex1ProtocolLabel	COUNT(*)
ВП	473
Деформации	511
ДДЗП ШОП	230
Инфекции	527
Всего	131
```

Вот что возвратил:

```
@regex1ProtocolLabel	COUNT(*)
ВП	1853
Деформации	1892
ДДЗП ШОП	1647
Инфекции	1911
Всего	1557
```

Нашел возможный источник проблемы: 0 в значении регекс-полей надо ставить строкой, вот так: `'0'`.

Тогда все вроде работает:

Исправляю, перезапускаю запрос:

```sql
SET @regex1ProtocolLabel = 'ВП';
SET @regex2ProtocolLabel = 'Деформации';
SET @regex3ProtocolLabel = 'ДДЗП ШОП';
SET @regex4ProtocolLabel = 'Инфекции';
SET @totalLabel = 'Всего';

SELECT @regex1ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex1` IS NOT NULL AND t1.`regex1` = '0'
    GROUP BY t2.`name`, t2.`year`
) t3_regex1
UNION ALL
SELECT @regex2ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex2` = '0'
    GROUP BY t2.`name`, t2.`year`
) t3_regex2
UNION ALL
SELECT @regex3ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex3` = '0'
    GROUP BY t2.`name`, t2.`year`
) t3_regex3
UNION ALL
SELECT @regex4ProtocolLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex4` = '0'
    GROUP BY t2.`name`, t2.`year`
) t3_regex4
UNION ALL
SELECT @totalLabel, COUNT(*) FROM
(
    SELECT COUNT(*)
    FROM `ft_form_9` t1 LEFT JOIN `ft_form_2` t2 ON t1.`record_id` = t2.`submission_id`
    WHERE t1.`regex1` != 1 AND t1.`regex2` != 1 AND t1.`regex3` != 1 AND t1.`regex4` != 1
    GROUP BY t2.`name`, t2.`year`
) t3_total
```

~~ОК, возвратил ожидаемые~~ (для поле «Всего» ожидаемого не было, поскольку его по имеющимся данным не рассчитать из-за смешанной спинальности: надо узнать, сколько вхождений было в пациентах со смешанной спинальностью, а таких данных нет):

Снова не возвратил.

```
@regex1ProtocolLabel	COUNT(*)
ВП	473
Деформации	511
ДДЗП ШОП	230
Инфекции	527
Всего	NA
```

Вот что возвратил:

```
@regex1ProtocolLabel	COUNT(*)
ВП	477
Деформации	512
ДДЗП ШОП	247
Инфекции	531
Всего	1557
```

Везде — чуть больше, чем расчетное, но расчетное — только на основании пациентов с чистой «Спинальной операцией», и поэтому следовало вообще-то ожидать, что реальное число _может_ быть чуть больше.

Общее число схождений и несхождений также в сумме не дает 1984, которые фигурировали выше.

В обще, ладно.

Резюме по вхождениям в пациентах пока отменяется: надо тут разбираться, это не по протоколу, а времени нет.

Для идиллии хочу еще запросы по регвырам выше переписать, применив там пользовательские переменные (я что-то тогда сразу и не подумал, что так можно) — тоже на потом: не по протоколу — время не буду тратить.

Так что перехожу к определению релевантности.

 Начинаю просмотр 484 в FormTools.
 
 Отсортированы корректно по TRNG, записи по одному пациенту идут группами.

 Приступаю к определению релевантности.

 Открываю разделы о целевой популяции во всех 4 протоколах, в соответствии с которыми и буду определять релевантность.

 Для пущего удобства сведения о записи выделил в FormTools в отдельную группу в самом верху вкладки.

 Поля `ID` и `ID из 3940` вообще убрал из отображения за полной их неинформативностью в контексте настоящих задач.

 Вот так теперь выглядит форма (копипаста из FormTools):

```
ЗаказПолеТип поляEditableПоиск
1TRNG для xa-led-p1m-aprТекстовое поле 
2ЗаписьRecord Picker 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по ВППереключатели 
2Релевантность по ВППереключатели 
3Группа по ВППереключатели 
4Наличие осложнений по ВППереключатели 
5Другие осложнения по ВПТекстовое поле 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по деформациямПереключатели 
2Релевантность по деформациямПереключатели 
3Группа по деформациямПереключатели 
4Наличие осложнений по деформациямПереключатели 
5Другие осложнения по деформациямТекстовое поле 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по ДДЗП ШОППереключатели 
2Релевантность по ДДЗП ШОППереключатели 
3Группа по ДДЗП ШОППереключатели 
4Наличие осложнений по ДДЗП ШОППереключатели 
5Другие осложнения по ДДЗП ШОПТекстовое поле 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1Вхождение по регвыру по инфекциямПереключатели 
2Релевантность по инфекциямПереключатели 
3Группа по инфекциямПереключатели 
4Наличие осложнений по инфекциямПереключатели 
5Другие осложнения по инфекциямТекстовое поле 
Добавить поле (ы) »

ЗаказПолеТип поляEditableПоиск
1№ ИБТекстовое поле 
2Комп. номер пациентаТекстовое поле 
3ФамилияТекстовое поле 
4ИмяТекстовое поле 
5ОтчествоТекстовое поле 
6ПолТекстовое поле 
7Дата рожденияТекстовое поле 
8Дата поступленияТекстовое поле 
9Дата выпискиТекстовое поле 
10Вид осмотраТекстовое поле 
11Тип осмотраТекстовое поле 
12Протокол осмотраTextarea 
13Телефон дом.Текстовое поле 
14Телефон сот.Текстовое поле 
15КомментарийТекстовое поле 
16Адрес регистрацииТекстовое поле 
17Адрес проживанияТекстовое поле 
18Диагноз по МКБ-10Текстовое поле 
19поле-индикатор пребывания на отделенияхТекстовое поле 
20Код операцииТекстовое поле 
21Дата операцииТекстовое поле 
22ASAТекстовое поле 
23Экстренная/ плановаяТекстовое поле 
24Полное наименование операцииТекстовое поле 
25Тип операцииТекстовое поле 
26Часов от момента поступленияТекстовое поле 
27Вид обезболиванияТекстовое поле 
28Начало наркозаТекстовое поле 
29Окончание наркозаТекстовое поле 
30Послеоперационный диагнозТекстовое поле 
31Описание операции/КТ/МРТTextarea 
32Вид спинальностиТекстовое поле 
Добавить поле (ы) »
```

Проставил первую релевантность.

Поскольку отображается только одна запись за раз, в случае наличия нескольких записей на пациента буду действовать так: при переходе на следующую запись всегда буду контролировать, не тот же это пациент, и если тот же, то буду пересматривать все записи для него, ~~заново принимая решение о релевантности уже на основании всех этих записей.~~ Решение о релевантности принимается _для записи_ (это если по журналу; по протоколам — для вхождения; но уж точно не для пациента). Просмотра всех записей по пациенту требует решение об осложнениях. И вообще я же уже написал все выше: см. «поясню, каким образом сейчас представляю себе процесс заполнения» — выше по тексту.

Так что, поскольку сразу же надо определять и осложнения, открываю плюс к разделам о популяции в протоколах еще и [[@Rampersaud2016]](https://pubmed.gov/27058499).

Короче, пошел я проставлять релевантность и осложнения для основной группы; на журнал больше не отвлекаюсь, пока не закончу.

Потом вновь вернусь к журналу и займусь контрольной группой.

Заметил такое место у [[@Rampersaud2016]](https://pubmed.gov/27058499) (в 1-м шаге):

> Furthermore, no operational definitions for specific AEs or postdischarge information on short- or long-term outcome of the case were provided.

Что, в принципе, похоже и на нашу ситуацию, но не совсем: у нас могут попасться случаи, по которым несколько госпитализаций за год, то есть может попасться и «postdischarge information».

По-моему, не криминал, но при сравнительном обсуждении нашей работы и [[@Rampersaud2016]](https://pubmed.gov/27058499) надо будет обязательно не забыть обязательно упомянуть об этом.

Столкнулся с первым релевантной записью, такой что для этого пациента имеется более одной записи, и возник вопрос: вписывать факт наличия осложнений в каждую запись или только в одну?

Прошел по частному протоколу, по общему протоколу, по журналу и нигде не нашел ответа на этот вопрос. Это странно, потому что я точно над этим думал — видимо, забыл это оговорить.

Думаю, дублировать решения в каждой записи будет избыточным, а значит не нужно этого делать.

Зато нужно будет учесть это обстоятельство на этапе извлечения данных по осложнениям, а именно считать пациента с осложнением, когда хотя бы в одной из записей, относящейся к этому пациенту, осложнение отмечено.

Попался случай, когда запись не имеет вхождений по протокольному регвыру, но релевантна (недоработка по протоколу инфекции: упущен вариант `эпидурит`).

Что с ней делать?

Сделаем по протоколу: ничего не будем отмечать по этому протоколу, ведь значится, что у этой записи нет вхождений, и такие записи мы не должны были бы увидеть вообще.

> Черт возьми! Там аж две записи по этому пациенту! И в обеих подробно расписан диагноз, расписаны протоколы операции, с изобилием терминов: «эпидурит», «гнойный», «гноя» — и ни одного вхождения! Мрак, как плохо мы проработали регулярку.

В целом процесс определения релевантности и осложнений по протоколу идет достаточно легко.

Поле «Другое» оказалось полезным: уже несколько раз пришлось использовать.

Особенно по вертебропластике, в плане которой встретились случаи повторных переломов и реопераций на смежных уровнях (спорный статус осложнения в спинальной хирургии вообще, в связи с чем, видимо, и нет такого в списках у [[@Rampersaud2016]](https://pubmed.gov/27058499), но общепризнанное неблагоприятное событие применительно к вертебропластике).

По ДДЗП ШОП обращает внимание изобилие ДДЗП ПКОП и ПСМТ ШОП среди нерелевантных результатов запроса.

По деформациям пока ни одной релевантной записи: все вхождения пока относятся к формальной фразе «смоделировано по лордозу» на стабилизирующей операции.

> Так-то в целом осложнения есть. По всем трем остальным протоколам хотя бы один случай, да есть, а я пока только на 45-й записи из 484. А то я беспокоился, что не окажется осложнений.

Предусмотрительным было оставление варианта ответа «Не выбрано» для всех переключателей: иногда нажимаю случайно не на тот, и иначе было бы никак уже не снять выделение.

Также правильным решением было включить все поля, что были в глобальном спинальном запросе (все 32 поля): иногда помогают прояснить картину.

В целом работать удобно.

Также правильным представляется решение в рамках этой, по сути, пилотной работы не углубляться в детализацию патологии и содержания выполненного лечения: случаи — очень разные, и, думаю, нередко сложно было бы с ходу определить их в ту или другую нозологическую группу.

Кстати, только сейчас осознал, что мы никак не предусмотрели фиксацию летальных исходов. Просто попался мне известный летальный случай, и тут я это осознал.

## Частота осложнений операций на позвоночнике против группы консервативного лечения: протокол исследования рутинных клинических данных центра неотложной взрослой хирургии позвоночника

## Примечание

Здесь пойдут какие-то общие правки по методам.

### Популяция

В соответствии с RECORD ([[@Benchimol2015]](https://pubmed.gov/26440803)), приводим в отдельности три уровня популяции:

1. Целевая популяция

    * Лица, для которых рассматривается вопрос об операции на позвоночнике.
    
2. Популяция базы данных

    * Медицинская информационная система НИИ скорой помощи им. И. И. Джанелидзе, где фиксируются все поступающие в институт пациенты, все выполняемые в институте операции и лучевые исследования и большая часть сведений из историй болезни (часть сведений при этом остается доступной только из бумажной истории), работает на полную силу ориентировочно с 2015 года.
    * Выбор только одного учреждения, причем именно этого, обусловлен производственными возможностями. При этом немаловажно отметить, что санкт-петербургский НИИ скорой помощи им. И. И. Джанелидзе является взрослым травмоцентром 1-го уровня, на уровне города специализирующемся в частности на лечении пострадавших с политравмой и пациентов с сепсисом, и на базе отделений института с 2010 функционирует городской центр неотложной хирургии позвоночника, в который распоряжением управления городским здравоохранением городскому бюро скорой помощи предписано направлять всех пациентов с острой спинальной патологией и пациентов со позвоночно-спинномозговой травмой со всей южной части города (подробнее см. в Дулаев А. К. и соавт., 2011, 2017, 2018). Другая часть пациентов с патологией позвоночника госпитализируется в институт планово.
    * Непосредственно к базе данных, обслуживающей МИС института, мы как исследователи не имеем доступа, поэтому IT-служба института по нашему техническому заданию сформировала запрос, в детали которого здесь углубляться не будем, так как это длинный разговор, см. для этого xs-led-dzhanelidze-global-spine-query. К пользованию этим запросом мы имеем свободный доступ и можем запускать его произвольное число раз.
    * Суть запроса в том, что он выбирает из всех случаев в базе случаи по двум критериям.
    * «Спинальная операция»: случаи, по которым выполнена операция с одним из внутренних кодов, которые мы расцениваем как спинальные (подробнее — в xs-led-dzhanelidze-global-spine-query).
    * «Спинальная КТ/МРТ»: случаи, не подошедшые по критерию «Спинальная операция», но по которым зарегистрировано хотя бы одно КТ- или МРТ-исследование, причем такое, в протоколе которого фигурирует текстовая маска «позвон». 
    * На выходе получаем таблицу Excel, где строками являются отдельные совпадения по критериям (то есть может быть более одной записи по одной госпитализации, если за данную госпитализацию выполнено несколько «спинальных операций» или «спинальных КТ/МРТ»), а поля — следующие:
    
        - № ИБ

            Номер медицинской карты, заведенной по случаю госпитализации.

        - Комп. номер пациента

            Уникальный номер пациента в МИС НИИ СП.

        - Фамилия
        - Имя
        - Отчество
        - Пол

            Женский или мужской.

        - Дата рождения
        - Дата поступления

            Дата и время поступления (часы и минуты).

        - Дата выписки

            Дата и время поступления (часы и минуты).
           
        - Вид осмотра

            Осмотр травматолога или осмотр нейрохирурга.

        - Тип осмотра

            Первичный, консультация, предоперационный эпикриз и так далее.

        - Протокол осмотра

            Полный текст осмотра.

        - Телефон дом.
        - Телефон сот.
        - Комментарий

            Комментарий к номеру телефона, предназначен для указания медицинским регистратором контактного лица.

            Иногда сам номер телефона оказывается внесен в это поле.

        - Адрес регистрации
        - Адрес проживания
        - Диагноз по МКБ-10

            Код МКБ-10 с различной точностью: от 3- до 5-значного кода, но обычно 4-значный.

            Соответствует коду выписного диагноза, который лицо, выписывающее пациента (обычно лечащий врач или ординатор), проставляет в статистическую карту выбывшего из стационара в бумажной истории болезни.

            Перенесение кода в МИС выполняют различные лица.

        - поле-индикатор пребывания на отделениях

            Если за весь период лечения пребывал хоть какое-то время на:
            
            * Травматологическом отделении No 1, вернуть 0001,
            * Травматологическом отделении No 2, вернуть 0010,
            * Нейрохирургическом отделении No 1, вернуть 0100,
            * Нейрохирургическом отделении No 2, вернуть 1000;
            * если успел побывать на ТО1 и на ТО2, 0011;
            * если успел побывать на всех этих отделениях, 1111;
            * если не переводился ни в одно из этих отделений, 0000
            * и т. д.

            Значение в этом поле подсчитывается автоматически в процессе выполнения запроса на основании данных МИС о движении пациентов между отделениями, и в выдаче по запросу мы видим уже заполненное поле.

        - Код операции

            Значение в это поле проставляет лицо, заполняющее протокол операции (хирург или ординатор), выбирая один из кодов из внутреннего списка, применяемого в НИИ СП.

            В качестве примера см. [коды спинальных операциий](https://github.com/p1m-ortho/xs-led-dzhanelidze-global-spine-query/blob/78283cc8ad9e151bacb246c082f1b49eacafffc4/METHOD.md#приложение-коды-спинальных-операций).

        - Дата операции
        - ASA

            Значение в это поле проставляет лицо, заполняющее протокол операции (хирург или ординатор), выбирая один вариант из этого списка:

            * Здоров
            * Легкие сист расс-ва
            * Значит сист расс-ва
            * Выраж. инв забол-е
            * Умирающий

        - Экстренная/ плановая

            Значение в это поле проставляет лицо, заполняющее протокол операции (хирург или ординатор), выбирая один из этих двух вариантов.

        - Полное наименование операции

            Стандартная формулировка, соответствующая данному коду операции.

        - Тип операции

            Значение в это поле проставляет лицо, заполняющее протокол операции (обычно хирург или ординатор), выбирая один вариант из этого списка:

            * Радикальная
            * Этапная
            * Паллиатив

        - Часов от момента поступления

            Значение в это поле проставляет лицо, заполняющее протокол операции (обычно хирург или ординатор), выбирая один вариант из этого списка:

            * в первые 6 часов
            * от 7 до 24 часов
            * позднее 24 часов

        - Вид обезболивания

            Значение в это поле проставляет лицо, заполняющее протокол операции (обычно хирург или ординатор), выбирая один вариант из этого списка:

            * местное
            * общее
            * в/в
            * сочетанная анестезия

        - Начало наркоза

            Значение в это поле проставляет лицо, заполняющее протокол операции (обычно хирург или ординатор), обычно на основании записи анестезиологической бригады, в часах и минутах.

        - Окончание наркоза

            Значение в это поле проставляет лицо, заполняющее протокол операции (обычно хирург или ординатор), обычно на основании записи анестезиологической бригады, в часах и минутах.

        - Послеоперационный диагноз

            Значение в это поле проставляет лицо, заполняющее протокол операции (обычно хирург или ординатор), в свободнотекстовой форме.

        - Описание операции/КТ/МРТ

            В зависимости от вида спинальности («Спинальная операция» или «Спинальная КТ/МРТ») поле содержит протокол операции (заполняет обычно хирург или ординатор) или протокол КТ- либо МРТ-исследования (заполняет обычно врач КТ или врач МРТ либо ординатор).

        - Вид спинальности

            «Спинальная операция» или «Спинальная КТ/МРТ».
    
3. Популяция исследования

    * Из результатов этого запроса мы выбираем только записи с датой поступления от 01.01.2018 и с датой выписки по 31.01.2019. Такой выбор обусловлен стремлением увязать все ныне текущие работы по РКД санкт-петербургского городского центра неотложной хирургии позвоночника (см. ветки xa-led-p1m-apr-conference) на одну субпопуляцию пациентов, а поскольку одна из работ — не по базе, а по опросникам,  данные по которым имеются в настоящее время только за данный период (для подробностей см. xc-led-dzhanelidze-proms-and-croms), то и ограничились и здесь им же.
    * Итоговую таблицу экспортируем в формат CSV, и дальнейшее сужение по ней см. в [разделе о методах получения данных из базы](#методы-получения-данных-из-базы).

## Методы получения данных из базы

Всю часть про работу с записями технически передумал делать не так. В каждом протоколе писать лень, поэтому пишу в общем здесь, но это и оправданно, потому что процесс не будет отличаться, и делать это буду в один присест.

А именно измененения по сравнению с протоколами будут следующими.

Сразу же выполню сортировку записей «Спинальная КТ/МРТ» случайным образом, как это описано в протоколах.

Для идиллии (чтобы у части записей не пустовало поле со случайным числом) записи «Спинальная операция» тоже случайно отсортирую аналогичным образом.

Загружу полученный CSV в FormTools.

Для этого в таблице к форме «Новая оценка» добавлю все те же поля, что есть в нашей выдаче (кстати, надо добавить список этих полей), и вставлю туда все записи.

Также добавлю для формы «Новая оценка» новый режим просмотра, который будет выводить только эти поля плюс поле для ссылки на форму «Новая запись» — все в нередактируемом виде.

Также ФИО, дату рождения и компьютерный номер (UPI) для всех записей из оригинального CSV скопирую в новый файл.

Устраню там 100%-ные дубликаты, документирую итоговое их число.

Затем добавлю эти записи в таблицу к форме «Новая запись».

Затем выполню SELECT LEFT JOIN таблицы «Новая запись» к таблице «Новая оценка» по полям ФИО, даты рождения и компьютерного номера (UPI).

Экспортирую результат в CSV, и из поля ID, взятого из формы «Новая запись», скопирую значения в сооветствующее связанное поле таблицы «Новая оценка».

Таким образом все записи будут полностью перенесены в FormTools.

Далее добавлю в таблицу к «Новой оценке» и соответствующему режиму просмотра следуюшие редактируемые поля:

* 4 бинарных поля-переключателя для факта вхождения по каждому из четырех регулярных выражений, приведенных в протоколах (Да / Нет);
* 4 бинарных поля-переключателя для оценки релевантности вхождений (Релеватно / Нерелеватно);
* числовое поле для нумерации групп записей (предполагаем, что между всеми четырьмя работами не будет ни одной пересекающейся группы, и поэтому одного поля должно быть достаточно);
* 4 поля-переключателя, отражающие принадлежность записи к основной или контрольной группе для каждой из 4 работ (основная группа / контрольная группа / не подходит);
* бинарное поле для фиксации наличия осложнений (Да / Нет);
* короткое свободнотекстовое поле на случай осложнений «Другое».

Дальше буду выполнять все аналогичные манипуляции, прописанные в протоколе, только к арсеналу инструментов добавится SQL (MySQL), и операции, которые рациональнее выполнить с помощью него, я буду выполнять с помощ него.

### Методы трансформации и анализа данных

> ПВЖ:
>
> Поработав по тезисам ССС с чеклистом [STROBE checklist for conference abstracts](http://www.strobe-statement.org/fileadmin/Strobe/uploads/checklists/STROBE_checklist_conference_abstract_DRAFT.pdf) и, дойдя до пункта «Report estimates of associations. If relevant, consider translating estimates of relative risk into absolute risk for a meaningful time period», обнаружили, что не подумали об этом.
>
> Обратились за разъяснениями по этому пункту к разъяснительному документу STROBE ([[@Vandenbroucke2007]](https://doi.org/10.1097/EDE.0b013e3181577511)), в результате чего пришли к пониманию того, что и для нас актуален этот пункт
>
> А именно актуально отразить в результатах number needed to harm (NNH) — «число лиц, подвергаемых лечению, для возникновения одного неблагоприятного исхода» (по аналогии с определением для number needed to treat в: Эпидемиологический словарь / под ред. Дж. М. Ласта., отв. ред. В. В. Власов. - 4-е изд. - М.: Открытый Институт Здоровья, 2009. - С. 245.).
>
> Что и сделаем во всех текущих работах по осложнениям (см. ветки xa-led-p1m-apr-conference) в дополнение к имеющимся методам.
>
> Соответствующее дополнение по методам см. ниже.

Подсчитаем и документируем общее количество групп с осложнениями и без них в основной и контрольной группах (4 числа).

Рассчитаем относительный риск (RR) и его 95%-ный ДИ, пользуясь [калькулятором RR от CCRB CUHK](https://www2.ccrb.cuhk.edu.hk/stat/confidence%20interval/CI%20for%20relative%20risk.htm).

Рассчитаем число лиц, подвергаемых хирургическому лечению, для возникновения одного осложнения (NNH) и его 95%-ный ДИ, пользуясь [калькулятором NNT от MedCalc](https://www.medcalc.org/calc/relative_risk.php).

Рассчитаем, пользуясь [калькулятором хи-квадрат от Jeremy Stangroom](https://www.socscistatistics.com/tests/chisquare2/default2.aspx), значение статистики хи-квадрат в тесте на независимость (1 степень свободы) и p-значение (2 числа).

### Результаты

Предстатавим только в текстовой форме в полном соответствии [разделу о методах трансформации и анализа данных](#методы-трансформации-и-анализа-данных).

Первичные данные сейчас публиковать не планируем, поскольку их анонимизация и подготовка к публикации займут дополнительное время, однако они будут доступны по запросу.

### Обсуждение

Интерпретируем полученный 95%-ный ДИ отношения шансов и NNH и p-значение.

Обсудим вопросы риска систематической ошибки, опираясь на схему ROBINS-I ([[@Sterne2016]](https://doi.org/10.1136/bmj.i4919)).

> ПВЖ: про ROBINS-I см. в METHOD.md в других ветках xa-led-p1m-apr-conference.

### Выводы

Интерпретируем полученные 95%-ные ДИ отношений шансов и NNH и p-значения.


## Финальный план по завершению работы над тезисами

**Сроки: срок написания финального варианта тезисов смещаем с утра на день 08.03, причины ясны из истории коммитов по веткам; срок отправки всех тезисов ДИК на проверку смещаем на утро 09.03**.

Финальный [почти наверняка](https://ru.wikipedia.org/wiki/Почти_достоверное_событие).

Это общий план, персонализированные для 5 из 5 авторов см.: [ЭБД](https://github.com/p1m-ortho/xa-led-p1m-apr-conference/blob/b18c821becc09b0f77061bcc63ab5f32791863b5/METHOD.md#финальный-план), [САС](https://github.com/p1m-ortho/xa-led-p1m-apr-conference/blob/888ba434d1b5338257f55216deb8bf6ee503e574/METHOD.md#финальный-план), [ССС](https://github.com/p1m-ortho/xa-led-p1m-apr-conference/blob/f054eee42f3904d1525d6e9a751a1cf9c7c8f8b0/METHOD.md#финальный-план), [РАБ](https://github.com/p1m-ortho/xa-led-p1m-apr-conference/blob/a943e67b44512ab5a2c3662fcc366f971d9661a2/METHOD.md#финальный-план), [НТМ](https://github.com/p1m-ortho/xa-led-p1m-apr-conference/blob/b37e58d41bf18a20c98732771333db9769f72246/METHOD.md#финальный-план).

> [23:05, 6.3.2019] Павел: Поскольку в пятницу все тезисы должен увидеть ДИК, реально из времени у нас остается только завтра. Поэтому завтра я возьму все, что кто успел наработать, и на основании этого постараюсь написать актуальность, цель и методы работы с базой и анализа полученных данных. Потом, по возможности, мы это с каждым обсудим, а дальше я собственно приступлю к реализации плана (работа с базой и анализ данных), а вы тем временем напишете окончательный вариант тезисов.

«Все, что кто успел наработать» — конкретно история коммитов в соответствующей ветке. Для каждой именной ветки я пройдусь в ней по каждому коммиту от начала и до конца.

А также пройду по каждому коммиту в мастере.

«Пройду» означает: прочту заголовок и тело коммита, ознакомлюсь с датой/давностью его подачи, ознакомлюсь с диффом. Все это буду делать — для ясности — в гитхабовском веб-интерфейсе.

> [23:08, 6.3.2019] Павел: Останется только в пятницу мне проставить туда цифры, и, по возможности, снова обсудив с каждым то, что получилось, я скомпилирую все тезисы в итоговые Word-файлы, которые отправлю ДИК.
> 
> [23:11, 6.3.2019] Павел: Дальше, в субботу и воскресенье, я займусь подготовкой документов на отправку, а вы все тем временем пройдете электронную регистрацию на конференцию.
> 
> [23:12, 6.3.2019] Павел: В воскресенье я отправлю всем готовые сканы тезисов с подписями и печатями, и Вы направите их в оргкомитет.

## Рассуждение 2

> [20:43, 6.3.2019] Павел: Хорошо. Давайте помыслим в конкретном русле.
> 
> [20:43, 6.3.2019] Павел: Конкретное русло заключается в том, что поджимают сроки по тезисам, и надо уже переходить к работе с базой, чтобы что-нибудь оттуда извлечь и что-нибудь на основании этого посчитать.
> 
> [20:44, 6.3.2019] Павел: Поскольку времени остается действительно мало, думаю, с базой я буду работать сам. В конце концов, я с самого начала говорил, что процесс извлечения оттуда информации носит сугубо технический характер.
> 
> [20:45, 6.3.2019] Павел: После того, как данные оттуда мы извлечем, нужно будет выполнить анализ этих данных — что-то посчитать.
> 
> [20:46, 6.3.2019] Павел: Более того, я Вам скажу, что и это процесс механический, и поэтому в условиях нехватки времени, думаю, его я тоже проделаю сам.
> 
> [20:51, 6.3.2019] Павел: В сухом остатке: что мне требуется для всего этого и что требуется сейчас и от меня, и от Вас — определиться, (а) с осмысленной целью проведения каких-либо манипуляций с этой базой, (б) содержанием этих манипуляций и (в) планом анализа полученных данных. Потом написать на основании всего этого эти чертовы тезисы на 1 лист, и вот тогда уже я действительно возьмусь за базу, а затем за анализ. Потом останется только вписать в написанные тезисы числа и согласно им скорректировать вывод — все, можно будет отправлять на проверку ДИК.


## Рассуждение 1

Я тут подумал, и коллективно по поводу тезисов сейчас вижу следующим образом.

У нас шести у всех в силу обстоятельств будут работы на основании т. н. рутинных клинических данных (РКД): НТМ, ЭБД, ССС, РАБ, ПВЖ — по МИС (медицинская информационная система) института Джанелидзе, САС — опросники, выдаваемые пациентам рутинно в институте Джанелидзе.

У всех — в рамках согласованных популяций (НТМ — вся вертебропластика; ЭБД — ДДЗП ШОП с неврологией; ССС — полиэтиологические деформации как причина обращения; РАБ — любые инфекции позвоночника; ПВЖ — повреждения типа C; ССС — любая спинальная патология).

По каждой теме необходимо найти актуальное приложение работы по РКД — _актуальность_.

Я так и не нашел времени завершить это рассуждение.